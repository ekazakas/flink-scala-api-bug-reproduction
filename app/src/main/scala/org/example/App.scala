package org.example

import com.typesafe.config.{Config, ConfigFactory}
import io.circe.Decoder
import org.apache.flink.api.common.eventtime.WatermarkStrategy
import org.apache.flink.api.common.typeinfo.TypeInformation
import org.apache.flink.configuration.Configuration
import org.apache.flink.streaming.api.windowing.assigners.SlidingEventTimeWindows
import org.apache.flink.streaming.api.windowing.windows.TimeWindow
import org.apache.flinkx.api.*
import org.apache.flinkx.api.function.ProcessWindowFunction
import org.apache.flinkx.api.serializers.*
import org.apache.flink.util.Collector

import java.time.Duration
import scala.util.Random
import scala.jdk.CollectionConverters.*

object App {

  import io.circe.generic.auto._
  import io.circe.config.syntax._

  given TypeInformation[Item] = deriveTypeInformation

  given Decoder[Configuration] =
    Decoder[Config].map {
      _.entrySet()
        .asScala
        .foldLeft(new Configuration()) { (configuration, entry) =>
          configuration.setString(entry.getKey, entry.getValue.unwrapped().toString)
          configuration
        }
    }

  def main(args: Array[String]): Unit = {
    val config = ConfigFactory.load()

    val flinkConf = config.as[FlinkConf]("flink")
      .toTry
      .get

    val env = StreamExecutionEnvironment.createLocalEnvironmentWithWebUI(flinkConf.localConfiguration)
    env.getConfig.disableAutoGeneratedUIDs()
    env.getConfig.enableObjectReuse()

    env.fromElements(gen(), gen(), gen(), gen())
      .uid("source")
      .assignTimestampsAndWatermarks(
        WatermarkStrategy
          .forBoundedOutOfOrderness[Item](Duration.ofSeconds(10))
          .withTimestampAssigner((element, _) => element.timestamp)
      )
      .uid("watermarks")
      .keyBy(_.key)
      .window(SlidingEventTimeWindows.of(
        Duration.ofMinutes(1),
        Duration.ofMinutes(1)
      ))
      .process(new Aggregator())
      .uid("windowing")
      .print()
      .uid("sink")

    env.execute("test")
  }

  private def gen() =
    Item(
      key = Random.alphanumeric.take(12).mkString,
      value = Random.alphanumeric.take(12).mkString,
      timestamp = System.currentTimeMillis()
    )
}


final case class FlinkConf(localConfiguration: Configuration)

final case class Item(key: String, value: String, timestamp: Long)

final class Aggregator extends ProcessWindowFunction[Item, Seq[Item], String, TimeWindow]  {
  override def process(key: String, context: Context, elements: Iterable[Item], out: Collector[Seq[Item]]): Unit = {
    out.collect(elements.toList)
  }
}